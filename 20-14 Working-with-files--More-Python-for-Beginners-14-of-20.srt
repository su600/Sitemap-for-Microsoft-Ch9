1
00:00:01,310 --> 00:00:03,645
>> So in the last module,

2
00:00:03,645 --> 00:00:05,295
we saw how we could

3
00:00:05,295 --> 00:00:07,905
figure out what is the
current working directory,

4
00:00:07,905 --> 00:00:10,574
how we can get a list of the files
if we're taking a directory,

5
00:00:10,574 --> 00:00:12,555
check if a file exists, and so on,

6
00:00:12,555 --> 00:00:14,010
which are great things to do before

7
00:00:14,010 --> 00:00:15,390
you start reading and
writing to files,

8
00:00:15,390 --> 00:00:17,445
make sure everything is
the way it should be,

9
00:00:17,445 --> 00:00:19,310
or to get a list of all the files

10
00:00:19,310 --> 00:00:20,885
you might need to open, for example,

11
00:00:20,885 --> 00:00:24,875
But how do I actually read
and write to specific files?

12
00:00:24,875 --> 00:00:27,755
Well, we have a few different
ways we can do that,

13
00:00:27,755 --> 00:00:30,380
Most of the time, we use
something called a file stream,

14
00:00:30,380 --> 00:00:32,375
So if you want to open up a file,

15
00:00:32,375 --> 00:00:34,250
you create a stream object,

16
00:00:34,250 --> 00:00:36,895
and you specify the name of
the file you want to open,

17
00:00:36,895 --> 00:00:39,180
the mode, and the buffer size,

18
00:00:39,180 --> 00:00:40,190
Now, most of the time,

19
00:00:40,190 --> 00:00:41,630
we leave the buffer
size to the default,

20
00:00:41,630 --> 00:00:43,190
We don't worry about that too much,

21
00:00:43,190 --> 00:00:45,485
The mode though can
be quite important,

22
00:00:45,485 --> 00:00:47,450
By default, when you open a file,

23
00:00:47,450 --> 00:00:49,250
Python assumes you
want to read the file

24
00:00:49,250 --> 00:00:51,260
because that is the
most common scenario,

25
00:00:51,260 --> 00:00:53,720
But you can specify that you want to

26
00:00:53,720 --> 00:00:56,720
write to the file or
append to the file,

27
00:00:56,720 --> 00:00:59,300
The difference between the
W for truncate and write,

28
00:00:59,300 --> 00:01:01,325
and A for append is simply,

29
00:01:01,325 --> 00:01:04,040
let's say someone has passed
you a file and you want

30
00:01:04,040 --> 00:01:06,590
to add additional lines
to the existing file,

31
00:01:06,590 --> 00:01:08,180
you would use A to add

32
00:01:08,180 --> 00:01:10,595
more lines without overwriting
what's already there,

33
00:01:10,595 --> 00:01:11,930
whereas the W will actually

34
00:01:11,930 --> 00:01:14,300
overwrite the existing
contents of the file,

35
00:01:14,300 --> 00:01:17,015
So make sure you know which
of those you want to use,

36
00:01:17,015 --> 00:01:20,060
X actually allows you to say,

37
00:01:20,060 --> 00:01:21,485
I want to write to the file,

38
00:01:21,485 --> 00:01:23,480
but this should be a
new file I'm creating,

39
00:01:23,480 --> 00:01:24,965
So if that file already exists,

40
00:01:24,965 --> 00:01:26,825
I actually want to get an error back,

41
00:01:26,825 --> 00:01:29,300
So this is another one
that can be useful,

42
00:01:29,300 --> 00:01:30,770
You really have to think a bit about

43
00:01:30,770 --> 00:01:34,310
your business logic if
you're creating a file,

44
00:01:34,310 --> 00:01:36,290
and then when you're
done with that file,

45
00:01:36,290 --> 00:01:37,310
some other program is supposed to

46
00:01:37,310 --> 00:01:39,410
copy it and move it somewhere else,

47
00:01:39,410 --> 00:01:42,170
Then you go to run
your program again,

48
00:01:42,170 --> 00:01:44,670
maybe you're overwriting a file
but it hasn't been copied yet,

49
00:01:44,670 --> 00:01:46,520
So sometimes we actually want to get

50
00:01:46,520 --> 00:01:48,960
an error if that file already exists,

51
00:01:48,960 --> 00:01:51,420
The plus indicates you're
doing an updating,

52
00:01:51,420 --> 00:01:54,540
and you can combine these
as well, You'll see,

53
00:01:54,540 --> 00:01:56,370
Depending on the type
of data you're going

54
00:01:56,370 --> 00:01:57,900
to be reading and
writing to the file,

55
00:01:57,900 --> 00:01:59,855
you can choose that
if it is a text file,

56
00:01:59,855 --> 00:02:02,105
so basic strings and so on,

57
00:02:02,105 --> 00:02:03,560
versus a binary file,

58
00:02:03,560 --> 00:02:06,300
which could be things like images,

59
00:02:06,770 --> 00:02:09,560
Most common scenario
you're going to encounter

60
00:02:09,560 --> 00:02:12,155
is you're going to
want to read a file,

61
00:02:12,155 --> 00:02:14,960
So if I create a stream,

62
00:02:14,960 --> 00:02:16,640
I just say open demo,txt,

63
00:02:16,640 --> 00:02:18,440
By default, it's a text file,

64
00:02:18,440 --> 00:02:21,460
By default, it assumes
I'm going in read mode,

65
00:02:21,460 --> 00:02:23,510
There's a few things we can do,

66
00:02:23,510 --> 00:02:25,670
One, we can just check and
see if it is readable at

67
00:02:25,670 --> 00:02:28,430
all because every
time you do file IO,

68
00:02:28,430 --> 00:02:30,320
sometimes weird things
happen and you're never

69
00:02:30,320 --> 00:02:31,790
sure is it because maybe I

70
00:02:31,790 --> 00:02:33,590
don't have permissions
to read the file?

71
00:02:33,590 --> 00:02:36,140
Or is it because there
are some weird characters

72
00:02:36,140 --> 00:02:38,795
in the file that will mess me
up or I can't find the file?

73
00:02:38,795 --> 00:02:40,430
So simple little things like, hey,

74
00:02:40,430 --> 00:02:42,010
just check the stream is readable,

75
00:02:42,010 --> 00:02:44,130
and then you at least know,
I have the permissions,

76
00:02:44,130 --> 00:02:45,210
I can read the stream,

77
00:02:45,210 --> 00:02:46,760
Now I can focus on reading it,

78
00:02:46,760 --> 00:02:48,890
So it just helps you debug what's

79
00:02:48,890 --> 00:02:51,805
going wrong and reduces
the chance of errors,

80
00:02:51,805 --> 00:02:56,075
You can specify a specific number
of characters you want to read,

81
00:02:56,075 --> 00:02:57,920
So I could literally say, read one,

82
00:02:57,920 --> 00:03:01,000
which will just read the very
first character in the stream,

83
00:03:01,000 --> 00:03:05,010
and readline will really
until the end of the line,

84
00:03:05,010 --> 00:03:07,005
Close simply closes a string,

85
00:03:07,005 --> 00:03:10,505
So if I had a lorem ipsum file,

86
00:03:10,505 --> 00:03:12,350
this would simply say, true,

87
00:03:12,350 --> 00:03:13,925
yes, the file is readable,

88
00:03:13,925 --> 00:03:16,100
Then when it reads
the first character,

89
00:03:16,100 --> 00:03:19,680
it reads the L, Here's something
I want to really highlight,

90
00:03:19,680 --> 00:03:22,615
is you'll notice that
when I readline,

91
00:03:22,615 --> 00:03:25,280
it continues from where
the stream left off,

92
00:03:25,280 --> 00:03:27,650
So once it read the first character,

93
00:03:27,650 --> 00:03:29,330
think of a little pointer moving over

94
00:03:29,330 --> 00:03:31,355
by one after it's read
that first character,

95
00:03:31,355 --> 00:03:32,600
So when I do a readline,

96
00:03:32,600 --> 00:03:34,550
it reads from that point onward,

97
00:03:34,550 --> 00:03:36,890
So it does not reread the L when you

98
00:03:36,890 --> 00:03:40,135
do the readline because I read
the first character separately,

99
00:03:40,135 --> 00:03:43,040
Now, what if we want
to write to a file?

100
00:03:43,040 --> 00:03:45,905
Well, first of all, we're going
to have to specify the mode,

101
00:03:45,905 --> 00:03:47,840
I'm saying I want a W for writing

102
00:03:47,840 --> 00:03:50,135
and T because I'm writing
text to the file,

103
00:03:50,135 --> 00:03:51,365
because of the default is reading,

104
00:03:51,365 --> 00:03:53,830
So if I want to write,
I have to specify it,

105
00:03:53,830 --> 00:03:57,000
We can use the write method to pass

106
00:03:57,000 --> 00:04:00,795
in a single string or
one or more characters,

107
00:04:00,795 --> 00:04:03,930
and I can use writelines to
pass in multiple strings,

108
00:04:03,930 --> 00:04:06,935
So now, it's really
important to be aware here,

109
00:04:06,935 --> 00:04:10,580
When you write the H, imagine
the cursor now blinking

110
00:04:10,580 --> 00:04:14,100
right after that H, So
when you write ello,

111
00:04:14,100 --> 00:04:16,430
it literally puts it
right after the letter H,

112
00:04:16,430 --> 00:04:18,530
and then when you
say write the space,

113
00:04:18,530 --> 00:04:19,775
it now puts in a space,

114
00:04:19,775 --> 00:04:21,770
and then when you pass
in the string world,

115
00:04:21,770 --> 00:04:22,910
it puts the word world,

116
00:04:22,910 --> 00:04:26,120
It does not put new lines
after any of these,

117
00:04:26,120 --> 00:04:27,455
If you want a new line,

118
00:04:27,455 --> 00:04:30,465
you have to tell it
to write a new line,

119
00:04:30,465 --> 00:04:33,610
Now, what's really
cool about writelines

120
00:04:33,610 --> 00:04:36,620
is I can give it a number of

121
00:04:36,620 --> 00:04:39,440
different string values
to write or I can give it

122
00:04:39,440 --> 00:04:43,790
an object that contains
maybe a list of strings,

123
00:04:43,790 --> 00:04:47,240
So one of the neat things that
I can do is I can actually

124
00:04:47,240 --> 00:04:51,350
pass in two names in a list,

125
00:04:51,350 --> 00:04:52,430
So I can create an object,

126
00:04:52,430 --> 00:04:53,630
which is a list of strings,

127
00:04:53,630 --> 00:04:56,475
and I can write those
names out to it,

128
00:04:56,475 --> 00:04:58,970
and it'll actually read
Susan and Christopher,

129
00:04:58,970 --> 00:05:01,730
and write the name Susan and
Christopher to the file as well,

130
00:05:01,730 --> 00:05:03,600
So this is a really wonderful trick

131
00:05:03,600 --> 00:05:04,850
if you've got a list of objects,

132
00:05:04,850 --> 00:05:06,755
You don't have to write
complicated loops

133
00:05:06,755 --> 00:05:09,140
to go through that list of
names and write each one,

134
00:05:09,140 --> 00:05:13,060
You can actually pass the list
of names directly to writelines,

135
00:05:13,060 --> 00:05:16,415
Then you'd simply use
close to say, I'm done,

136
00:05:16,415 --> 00:05:18,335
close the stream, flush out the data,

137
00:05:18,335 --> 00:05:20,750
and our file is ready to go,

138
00:05:20,750 --> 00:05:22,900
Now, there's a couple of

139
00:05:22,900 --> 00:05:24,600
things I just want to point
out when you're working

140
00:05:24,600 --> 00:05:26,830
with streams that
might not be obvious

141
00:05:26,830 --> 00:05:28,030
and it can be a little confusing when

142
00:05:28,030 --> 00:05:29,230
you're working with
this the first time,

143
00:05:29,230 --> 00:05:31,210
You're not actually
writing to the file,

144
00:05:31,210 --> 00:05:33,205
you're writing to a file stream,

145
00:05:33,205 --> 00:05:35,795
and that stream goes to the file,

146
00:05:35,795 --> 00:05:38,145
So let's say I open up a file,

147
00:05:38,145 --> 00:05:39,710
and I say I want to open up to write,

148
00:05:39,710 --> 00:05:42,070
and it's a text file,
and I write demo,

149
00:05:42,070 --> 00:05:44,570
I'm writing that to this stream,

150
00:05:44,570 --> 00:05:47,545
You can actually use the seek command

151
00:05:47,545 --> 00:05:50,110
to reposition where
you are in the stream,

152
00:05:50,110 --> 00:05:52,390
So imagine moving the cursor

153
00:05:52,390 --> 00:05:54,265
around for where things
are being written,

154
00:05:54,265 --> 00:05:55,810
So if I say seek zero,

155
00:05:55,810 --> 00:05:57,580
that will literally put the cursor

156
00:05:57,580 --> 00:05:59,170
right back at the
beginning of a stream,

157
00:05:59,170 --> 00:06:00,520
So if I do another write,

158
00:06:00,520 --> 00:06:05,520
it's going to overwrite
D-E-M-O with C-O-O-L,

159
00:06:05,520 --> 00:06:07,400
But the fifth character still has

160
00:06:07,400 --> 00:06:08,840
an exclamation mark on it

161
00:06:08,840 --> 00:06:10,865
because I haven't overwritten
the fifth character,

162
00:06:10,865 --> 00:06:12,910
Now, the flush command,

163
00:06:12,910 --> 00:06:15,410
Most of the time, you
aren't going to need to use

164
00:06:15,410 --> 00:06:17,720
the flush command because
what the flush command is

165
00:06:17,720 --> 00:06:21,080
going to do for you is it
actually flushes the data out

166
00:06:21,080 --> 00:06:24,865
of the stream to the file,

167
00:06:24,865 --> 00:06:27,470
Now, what that means is if you do

168
00:06:27,470 --> 00:06:30,680
a flush and there's another piece
of code out there somewhere,

169
00:06:30,680 --> 00:06:32,780
or somebody out there
now opens up the file,

170
00:06:32,780 --> 00:06:35,805
they're going to see the
changes you've made,

171
00:06:35,805 --> 00:06:38,385
So they're going to see the
word cool in that file,

172
00:06:38,385 --> 00:06:40,810
But it's not actually
necessarily saved to disk yet,

173
00:06:40,810 --> 00:06:42,110
It just means if
somebody else opens up

174
00:06:42,110 --> 00:06:43,820
the file right now in memory,

175
00:06:43,820 --> 00:06:47,415
then those values you wrote
can be read inside the file,

176
00:06:47,415 --> 00:06:49,375
When you do the close,

177
00:06:49,375 --> 00:06:51,560
that will actually flush anything you

178
00:06:51,560 --> 00:06:54,125
haven't already flushed
out and close the stream,

179
00:06:54,125 --> 00:06:56,440
and now it's actually saved
permanently to the file,

180
00:06:56,440 --> 00:06:58,700
So a lot of times, you
can just close it,

181
00:06:58,700 --> 00:07:00,800
You don't have to call
flush explicitly,

182
00:07:00,800 --> 00:07:03,230
but just wanted to put that
out there because it's

183
00:07:03,230 --> 00:07:06,290
a very common point of confusion
for a lot of new developers,

184
00:07:06,290 --> 00:07:09,485
is what the heck does flush do as
opposed to what does close do,

185
00:07:09,485 --> 00:07:12,020
So flush simply takes
what's in the file stream,

186
00:07:12,020 --> 00:07:13,910
writes it to the file,

187
00:07:13,910 --> 00:07:15,470
but it's not saved to disk yet,

188
00:07:15,470 --> 00:07:16,910
It just means it's
written to the file,

189
00:07:16,910 --> 00:07:19,180
the operating system decides
when to save it to disk,

190
00:07:19,180 --> 00:07:21,560
So it's something we typically use
just because the file stream is

191
00:07:21,560 --> 00:07:23,930
getting big and we want to
write that to the file,

192
00:07:23,930 --> 00:07:25,550
or because we have some other code

193
00:07:25,550 --> 00:07:27,470
somewhere and we want
to make sure anybody

194
00:07:27,470 --> 00:07:31,100
else who might be opening that
file can see what we've written,

195
00:07:31,100 --> 00:07:32,815
even though we might
still be working on it,

196
00:07:32,815 --> 00:07:35,260
So that's what flush will do for you,

197
00:07:36,680 --> 00:07:40,280
I just want to highlight the
neat aspect of using seek,

198
00:07:40,280 --> 00:07:42,650
is you can actually go
back and overwrite things,

199
00:07:42,650 --> 00:07:45,140
So when I do seek, I move back
to the beginning of the file,

200
00:07:45,140 --> 00:07:46,985
So the word D-E-M-O, demo,

201
00:07:46,985 --> 00:07:48,530
got overwritten by C-O-O-L,

202
00:07:48,530 --> 00:07:51,500
but you'll still see the
exclamation mark at the end of it,

203
00:07:51,500 --> 00:07:54,450
Now let's go try that in some code,

